from SimPEG import Mesh, Utils
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from scipy.sparse import spdiags,csr_matrix, eye,kron,hstack,vstack,eye,diags
import copy
from scipy.constants import mu_0
from SimPEG import SolverLU
from scipy.sparse.linalg import spsolve,splu
from SimPEG.EM import TDEM
from SimPEG.EM.Analytics.TDEM import hzAnalyticDipoleT,hzAnalyticCentLoopT
from scipy.interpolate import interp2d,LinearNDInterpolator
from scipy.special import ellipk,ellipe

import sys
path ="../../pymatsolver/" 
#path = "../../../Documents/pymatsolver/"
sys.path.append(path)
from pymatsolver import BicgJacobiSolver, PardisoSolver

def rectangular_plane_layout(mesh,corner, closed = False,I=1.):
	"""
	corner: sorted list of four corners (x,y,z)
	
	2--3
	|  |
	1--4
	
	y
	|
	|--> x
	
	Output:
	Js
	
	"""
	
	Jx = np.zeros(mesh.nEx)
	Jy = np.zeros(mesh.nEy)
	Jz = np.zeros(mesh.nEz)
	
	indy1 = np.logical_and( \
			np.logical_and( \
			np.logical_and(mesh.gridEy[:,0]>=corner[0,0],mesh.gridEy[:,0]<=corner[1,0]), \
			np.logical_and(mesh.gridEy[:,1] >=corner[0,1] , mesh.gridEy[:,1]<=corner[1,1] )), 
			(mesh.gridEy[:,2] == corner[0,2]
			)
			)
	indx1 = np.logical_and( \
			np.logical_and( \
			np.logical_and(mesh.gridEx[:,0]>=corner[1,0],mesh.gridEx[:,0]<=corner[2,0]), \
			np.logical_and(mesh.gridEx[:,1] >=corner[1,1] , mesh.gridEx[:,1]<=corner[2,1] )), 
			(mesh.gridEx[:,2] == corner[1,2]
			)
			)
	indy2 = np.logical_and( \
			np.logical_and( \
			np.logical_and(mesh.gridEy[:,0]>=corner[2,0],mesh.gridEy[:,0]<=corner[3,0]), \
			np.logical_and(mesh.gridEy[:,1] <=corner[2,1] , mesh.gridEy[:,1]>=corner[3,1] )), 
			(mesh.gridEy[:,2] == corner[2,2]
			)
			)
			
	if closed:
		indx2 = np.logical_and( \
				np.logical_and( \
				np.logical_and(mesh.gridEx[:,0]>=corner[0,0],mesh.gridEx[:,0]<=corner[3,0]), \
				np.logical_and(mesh.gridEx[:,1] >=corner[0,1] , mesh.gridEx[:,1]<=corner[3,1] )), 
				(mesh.gridEx[:,2] == corner[0,2]
				)
				)
		
	else:
		indx2 = []
		
	Jy[indy1] = -I
	Jx[indx1] = -I
	Jy[indy2] = I
	Jx[indx2] = I
	
	J = np.hstack((Jx,Jy,Jz))
	J = J*mesh.edge
	
	return J
			
	
def BiotSavart_B(locs,mesh,Js):
	"""
	Compute the magnetic field generated by current discretized on a mesh using Biot-Savart law

	Input:
	locs: observation locations
	mesh: mesh on which the current J is discretized
	Js: discretized source current in A-m (Finite Volume formulation)

	Output:
	B: magnetic field [Bx,By,Bz]
	"""

	c = mu_0/(4*np.pi)
	nwire = np.sum(Js!=0.)
	ind= np.where(Js!=0.)
	ind = ind[0]
	B = np.zeros([locs.shape[0],3])
	gridE = np.vstack([mesh.gridEx,mesh.gridEy,mesh.gridEz])
	
	for i in range(nwire):
		# x wire
		if ind[i]<mesh.nEx:
			r = locs-gridE[ind[i]]
			I = Js[ind[i]]*np.hstack([np.ones([locs.shape[0],1]),np.zeros([locs.shape[0],1]),np.zeros([locs.shape[0],1])])
			cr = np.cross(I,r)
			rsq = np.linalg.norm(r,axis=1)**3.
			B = B + c*cr/rsq[:,None]
		# y wire
		elif ind[i]<mesh.nEx+mesh.nEy:
			r = locs-gridE[ind[i]]
			I = Js[ind[i]]*np.hstack([np.zeros([locs.shape[0],1]),np.ones([locs.shape[0],1]),np.zeros([locs.shape[0],1])])
			cr = np.cross(I,r)
			rsq = np.linalg.norm(r,axis=1)**3.
			B = B + c*cr/rsq[:,None]
		# z wire
		elif ind[i]<mesh.nEx+mesh.nEy+mesh.nEz:
			r = locs-gridE[ind[i]]
			I = Js[ind[i]]*np.hstack([np.zeros([locs.shape[0],1]),np.zeros([locs.shape[0],1]),np.ones([locs.shape[0],1])])
			cr = np.cross(I,r)
			rsq = np.linalg.norm(r,axis=1)**3.
			B = B + c*cr/rsq[:,None]
		else:
			print 'error: index of J out of bounds (number of edges in the mesh)'
	
	return B


def BiotSavart_A(locs,mesh,Js):
	"""
	Compute the magnetic field generated by current discretized on a mesh using Biot-Savart law

	Input:
	locs: observation locations
	mesh: mesh on which the current J is discretized
	Js: discretized source current in A-m (Finite Volume formulation)

	Output:
	A: magnetic vector potential [Ax,Ay,Az]
	"""

	c = mu_0/(4*np.pi)
	nwire = np.sum(Js!=0.)
	ind= np.where(Js!=0.)
	ind = ind[0]
	A = np.zeros([locs.shape[0],3])
	gridE = np.vstack([mesh.gridEx,mesh.gridEy,mesh.gridEz])
	
	for i in range(nwire):
		# x wire
		if ind[i]<mesh.nEx:
			r = locs-gridE[ind[i]]
			I = Js[ind[i]]*np.hstack([np.ones([locs.shape[0],1]),np.zeros([locs.shape[0],1]),np.zeros([locs.shape[0],1])])
			#cr = np.cross(I,r)
			rsq = np.linalg.norm(r,axis=1)
			A = A + c*I/rsq[:,None]
		# y wire
		elif ind[i]<mesh.nEx+mesh.nEy:
			r = locs-gridE[ind[i]]
			I = Js[ind[i]]*np.hstack([np.zeros([locs.shape[0],1]),np.ones([locs.shape[0],1]),np.zeros([locs.shape[0],1])])
			#cr = np.cross(I,r)
			rsq = np.linalg.norm(r,axis=1)
			A = A + c*I/rsq[:,None]
		# z wire
		elif ind[i]<mesh.nEx+mesh.nEy+mesh.nEz:
			r = locs-gridE[ind[i]]
			I = Js[ind[i]]*np.hstack([np.zeros([locs.shape[0],1]),np.zeros([locs.shape[0],1]),np.ones([locs.shape[0],1])])
			#cr = np.cross(I,r)
			rsq = np.linalg.norm(r,axis=1)
			A = A + c*I/rsq[:,None]
		else:
			print 'error: index of J out of bounds (number of edges in the mesh)'
	
    #Take care of problem that A and J live at the same place on the mesh (can probably be improved)
	nanindexx = np.isnan(A[:,0])+np.isinf(A[:,0])
	nanindexy = np.isnan(A[:,1])+np.isinf(A[:,1])
	nanindexz = np.isnan(A[:,2])+np.isinf(A[:,2])
    #
	Ainterpx = LinearNDInterpolator(locs[np.logical_not(nanindexx)],A[np.logical_not(nanindexx),0])
	Ainterpy = LinearNDInterpolator(locs[np.logical_not(nanindexy)],A[np.logical_not(nanindexy),1])
	Ainterpz = LinearNDInterpolator(locs[np.logical_not(nanindexz)],A[np.logical_not(nanindexz),2])
    
	A[nanindexx,0] = Ainterpx(locs[nanindexx,:])
	A[nanindexy,1] = Ainterpy(locs[nanindexy,:])
	A[nanindexz,2] = Ainterpz(locs[nanindexz,:])
    
	return A


def time_wrapper(time):
    timelist = []
    for i in range(len(time)):
        for j in range(time[i][1]):
            if len(timelist)>0:
                timelist.append(timelist[-1]+time[i][0])
            else:
                timelist.append(time[i][0])
    
    return np.r_[timelist]

#Backward Euler function
def Backward_Euler_linear(u0,A,time,Ainv = None):
    """
    u_{t+1} = u_t + k*f(u_{t+1})
    
    input:
    u0: initialisation
    f: update function for Forward Euler 
    time: time steps output of time_wrapper
    
    output:
    list of array at the different times steps
    """
    ulist=[u0]
    uaux=u0
    
    for i in range(len(time)):
        k = time[i][0]
        if Ainv == None:
        	Id = eye(A.shape[0],A.shape[1])
        	#Ainv = splu(Id-k*A)
        	Ainv1 = PardisoSolver(Id-k*A)
        	print 'BE: solving for time step: ',k
        else:
        	Ainv1 = Ainv
        for j in range(time[i][1]):
            #u1 = Ainv.solve(uaux)
            u1 = Ainv1*uaux
            ulist.append(u1)
            uaux=u1
    return ulist  

#BDF2 function
def BDF2_linear(u0,A,time,Ainv = None):
    """
    $3 u^{n+1} -4 u^n + u^{n-1} = 2k*f(u^{n+1},t^{n+1}) $
    
    input:
    u0: initialisation
    f: update function for Forward Euler 
    time: time steps output of time_wrapper
    
    output:
    list of array at the different times steps
    """
    #Initialisation
    time_init = [(time[0][0],1)]

    newtime = [(time[0][0],time[0][1]-1)]
    for temp in range(1,len(time)):
        newtime.append(time[temp])
    
    ulist=Backward_Euler_linear(u0,A,time_init,Ainv)
    uaux0 = ulist[-2]
    uaux1 = ulist[-1]

    for i in range(len(newtime)):
        k = newtime[i][0]
        if Ainv == None:
            Id = eye(A.shape[0],A.shape[1])
            #Ainv = splu(Id-k*A)
            Ainv1 = PardisoSolver(1.5*Id-k*A)
            print 'BDF2: solving for time step: ',k
        else:
        	Ainv1 = Ainv
        for j in range(newtime[i][1]):
            #u1 = Ainv.solve(uaux)
            rhs = 2.*uaux1-0.5*uaux0
            u1 = Ainv1*(rhs)
            ulist.append(u1)
            uaux1=ulist[-1]
            uaux0=ulist[-2]
    return ulist

#Backward Euler function
def BDF4_linear(u0,A,time,Ainv=None):
    """
    $25 u^{n+1} -48 u^n + 36 u^{n-1} - 16 u^{n-2} + 3 u^{n-3} = 12k*f(u^{n+1},t^{n+1}) $
    
    input:
    u0: initialisation
    f: update function for Forward Euler 
    time: time steps output of time_wrapper
    
    output:
    list of array at the different times steps
    """
    #Initialisation
    time_init = [(time[0][0],3)]
    
    newtime = [(time[0][0],time[0][1]-3)]
    for temp in range(1,len(time)):
        newtime.append(time[temp])
    
    #Initialisation: Backward Euler
    ulist=BDF2_linear(u0,A,time_init)
    uaux0 = ulist[0]
    uaux1 = ulist[1]
    uaux2 = ulist[2]
    uaux3 = ulist[3]
    
    for i in range(len(newtime)):
        k = newtime[i][0]
        if Ainv == None:
        	Id = eye(A.shape[0],A.shape[1])
        	#Ainv = splu(Id-k*A)
        	Ainv1 = PardisoSolver(Id-(12./25.)*k*A)
        	print 'solving for time step: ',k
        else:
        	Ainv1 = Ainv
        for j in range(newtime[i][1]):
            #u1 = Ainv.solve(uaux)
            u1 = Ainv1*((48./25.)*uaux3-(36./25.)*uaux2+(16./25.)*uaux1-(3./25.)*uaux0)
            ulist.append(u1)
            uaux0 = ulist[-4]
            uaux1 = ulist[-3]
            uaux2 = ulist[-2]
            uaux3 = ulist[-1]
    return ulist